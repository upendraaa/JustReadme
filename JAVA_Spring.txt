JAVA 8
Function interface vs iterface
Stream Vs Collection
Abstract, Interface
DSA
Duplicate in two arrays
Stack, heap
Garbage collection
Stack overflow error
out of memory error

Why is use spring annotation
Spring boot functionality

Java 8 interface
method()            mandatory override
static method()     can not be override, utility method for interface
default method() have implementation, can be override, support backward compatibility

Functional interface: SAM
single abstract method interface
@FunctionalInterface (This annotation is optional but recommended)
-------
Optional

Optional<String> optionalValue = findById(23);
optionalValue.get()
optionalValue.ifPresent()
optionalValue.isPresent()
optionalValue.orElse()




________________________________
Stream:
Can have 0 or more intermediate operation
1 Terminal operation
Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.














________________________________
ReactJS:
closure in java script
Hoisting
Asynchronous function
this keyword in react
Interface in react js
Intercepter
how to share the data parent to child and child to parent
what is data type of undefined


------------------------------------
what are the various way to configure properties in spring boot application?

commandline
CommandLineRunner
@Value


What are the different type of bean scopes in sprint boot application?
Singleton (default)
prototype
session
request

Concept of spring boot starter?

________________________________

Spring boot is developed on top of spring framework (MVC) layer. 
spring boot contain
Presentation layer (Controllers and rest call)
Business layer   (Validation)
Persistent layer (Transistion businesss object to database object)
Database layer  (To crud operation)

MongoDB (NoSql)
Store data as BSON (Binary format of JSON)
Document ( Unit of data storage, similar to ROW in rdbms)
Collection ( Similar to table in rdbms)
Sharding (Is the process to distribute data across the multiple machine in MongoDB cluster, to acheive horizontal scalability)
Index 
ObjectId (12 byte identifier (Machine ID + Process ID + Counter) generated by mongodb to uniquely identify the document in collection)
db.collection.find()
db.collection.findOne()

__________________________________

JPA and hibernate 
Used as a ORM (Object relational mapping) for RDBMS

Spring data MongoDB
Used as ODM (Object documented mapping) used for mongo db

________________________________
select * from users where age > 25;

db.users.find({age:{$gt:25}})

SELECT * FROM inventory WHERE status = "A" OR qty < 30

findIterable = collection.find(or(eq("status", "A"), lt("qty", 30)));

db.inventory.find({ $or: [ { status: 'A' }, { qty: { $lt: 30 } } ] })

-------------------------
Prompt engineering
Instruction
Question
InputData
Example

________________________________
JNDI (Java naming and directory interface)

Message oriented middleware
ActiveMQ,RabbitMQ,JBossMQ,

JMS
Point to point
Proudcer - sent request (MOM) - consumer
Pub/Sub
Producer- (Sent request) (MOM) - Multiple consumer

Spring JMS = JMS + MOM

------------------------Annotation
@SpringBootApplication
 @ComponentScan  (To scan the bean so it visible to Spring IOC)
 @EnableAutoConfiguration  (Automatically enable jar configuration from pom.xml)
 @Cofiguration  (For java based configuration)
 
Sterotype Annotataion
@Component (Use to create spring bean in application context)
 @Service
 @RestController/Controller
 @Repository
 
Spring core annotation
@Configuration
@Bean
@Autowired
@Qualifier  @Qualifier("ClassName")
If a interface ExampleInterface, is implemented by two class and
trying to 
@Autowired
@Qualifier("ClassA")
ExampleInterface exampleInterface


@Primary
ClassA

By default bean is eager loader, to make 
it lazy need to annotate with @Lazy

@Component
@Lazy
ClassA

Create the bean only if required


Read the data from properties file
@Value


@Value("${app.name}")
private String name;

As default @value will read the application.properties to define other 
properties to read
@PropertySource("classpah:custom.properties")
public class ClassA

To read multiple properties from the properties file

@ConfigurationProperties(prefix="app")
@Data
@Component
pubiic class pojo{
}
@ConfigurationProperties

To set active application.properties file, To read different properties file configuration ex application.dev.properties
@Profile("dev")
@Profile


Singleton,prototype etc
@Scope("Sigleton")
public class ClassA
@Scope

-------------
Rest annotation
@RestController

@RequestMapping(value="/save", method =
RequestMethod.POST, consumes = "application/json", produces = "application.json")

@RestControllerAdvice
public class ClassExceptionHander

________________________________
Spring data jpa related notation

@Entity (This object going to perform db operation)
@Table
@Table(name = "Table_Name") if this annotation not given, it create class name as table name

@Column to give custom name to column
@Transactional ( Where need to handle failure and rollback)

@Transactional(isolation = Isolation.READ_COMMITED)
public Product addProduct( Product product)

 @OnetoOne
 @OneToMany
 @ManyToOne
 @ManyToMany
 
A product have many items, we can make item entity as one to many mapping
@OneToMany(targetEntity = Item.class,
fetch = FetchType.EAGER)
@JoinColumn(name = "skf")
List<Items> items;

in item entity we have have to 
make prodct as @ManyToOne


______Spring Security---

https://www.youtube.com/watch?v=R76S0tfv36w

1) In properties file give the credentials, then it ask for username and password in UI

spring.security.user.name = upen
spring.security.user.password = password

2) 
@Configuration
@EnableWebSecurity
public class SecurityConfig{

}

3)
Can create UserDetailsField for Authorization



String s1 = "abc";
String s2 = "abc";

System.out.println("s1 == s2 is:" + s1 == s2);
  
-------------------------
https://docs.spring.io/spring-framework/reference/core/aop/introduction-defn.html
  
  AOP
  Aspect
  Joint point
  Advice
  Pointcut
  
  Introduction
  Target Object (Advised object)
  Aop Proxy
  Weaving
  
  
@Configurable(autowire=Autowire.BY_TYPE) or @Configurable(autowire=Autowire.BY_NAME)



-----------------

To create the docker image
docker build -t springserver
Docker Image
OS
OS libraries
Application

To check docker images
docker images

Docker Image - > Docker run -> Container

A Single instance of application (docker image) is running in single container.

Docker container orchestration can be done by (Kubernetes or sworm)

Kubernetes:
It create multiple instance of application to run in single container
It allows
Authenticatioin
Monitoring
Logging
Database
Connect with the other application
Load balancing
Self healing
Orchestration

------
Packaged application with docker and installed kubernetes
To deploy with kubernetes intergration it required helm

Command to get the helm chart
helm repo list

Add helm chart to the application
To deploy kubernetes app
(Kubernetes instance also called pod)
helm install --name chart/springserver

To chehk the running status
helm status

To upgrade the changes
helm upgrade

To rollback
helm rollback

------------------------
Microservices communicate each other
Synchronous call HTTP/Rest
Asynchronout publish subscribe with message broker
API gateway   one common entry point of all the api's


-----------------------
How to handle microservices failure
Retry Mechanisms
CiruitBreaker
Fallback machanisms
Timeouts
BulkHeading
HealthChecks


_______________________________________

In MongoDB, transactions are supported starting from version 4.0, and they allow you to perform multiple operations on multiple documents within a single transaction. Here's an overview of how you can handle transactions in MongoDB using the official MongoDB Java driver:

1. **Start a Transaction**: To start a transaction, you need to use the `ClientSession` object from the MongoDB Java driver. You can start a transaction by calling the `startTransaction` method on a client session.

```java
ClientSession session = client.startSession();
session.startTransaction();
```

2. **Perform Operations Within the Transaction**: Once the transaction is started, you can perform various database operations within the transaction using the session object. For example, you can insert, update, or delete documents as part of the transaction.

```java
MongoCollection<Document> collection = database.getCollection("myCollection");
collection.insertOne(session, new Document("key", "value"));
```

3. **Commit or Abort the Transaction**: After performing the necessary operations, you can choose to commit the transaction to make the changes permanent or abort the transaction to discard the changes.

```java
session.commitTransaction();
// OR
session.abortTransaction();
```

4. **Handle Transactional Errors**: If any error occurs during the transaction, you can catch the exception and handle it accordingly. For example, you might need to abort the transaction and handle the error gracefully.

```java
try {
    // Perform operations within the transaction
    session.commitTransaction();
} catch (MongoException e) {
    session.abortTransaction();
    // Handle the exception
}
```

It's important to note that MongoDB transactions are only supported on replica sets and sharded clusters. Additionally, transactions are not supported on standalone MongoDB instances



  
  
  
  



 
